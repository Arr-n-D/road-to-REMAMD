package main

import (
	"fmt"
	"os"
	"time"

	"golang.org/x/sys/windows"
	_ "golang.org/x/sys/windows"
)

func main() {
	var proc *os.Process
	args := os.Args[1:]
	// check if args isn't empty

	if len(args) == 0 {
		fmt.Println("Usage: go run main.go <process name>")
		os.Exit(1)
	}

	procNameToFind := args[0] + ".exe"

	fmt.Println("Looking for :" + procNameToFind)
	// sleep before printing again
	waitTime := 5 * time.Second
	lastPrintTime := time.Now()

	// while proc is nil
	for proc == nil {
		procId := findProcessIdByName(procNameToFind)

		if procId != 0 {
			fmt.Println("Found Process Id: ", procId)
			proc, _ = os.FindProcess(int(procId))
		}

		// Check if waitTime has passed since the last print
		if time.Since(lastPrintTime) >= waitTime && proc == nil {
			fmt.Println("Still looking for :", procNameToFind)
			lastPrintTime = time.Now()
		}
	}
}

var waitTime = 5 * time.Second
var lastPrintTime2 = time.Now()

func findProcessIdByName(name string) uint32 {
	snapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)

	if err != nil {
		// Check if waitTime has passed since the last print
		if time.Since(lastPrintTime2) >= waitTime {
			fmt.Println(err)
			lastPrintTime2 = time.Now()
		}
		return 0
	}
	p := windows.ProcessEntry32{Size: 568}

	for {
		e := windows.Process32Next(snapshot, &p)
		if e != nil {
			// Check if waitTime has passed since the last print
			if time.Since(lastPrintTime2) >= waitTime {
				fmt.Println(e)
				lastPrintTime2 = time.Now()
			}
			return 0
		}

		if windows.UTF16ToString(p.ExeFile[:]) == name {
			return p.ProcessID
		}
	}
}
